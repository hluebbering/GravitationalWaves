---
title: "Gravitational Wave Analysis in Python"
subtitle: "CSE 515: Software Design For Data Science"
author: "Hannah Luebbering"
output:
  html_document: 
    css: assets/main.css
    toc: yes
    toc_float: yes
bibliography: assets/references.bib
nocite: '@*'
# knit: pagedown::chrome_print
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = ".") })
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(kableExtra)
library(dplyr)
library(knitr)
library(utils)

```


## Introduction


This report details software design decisions and analysis of the `GravitationalWaves` package system, with respect to existing software libraries. The software libraries used for the basis of this project include `legwork` and `riroriro`. Legwork is a python package for computing evolution and detection rates of gravitational-wave sources discovered by space-based detectors such as LISA. Riroriro is a python package for simulating and evaluating gravitational waves.



In the following, I address the major software design decisions, sofware requirements, usage guidelines, and the extensibiility of the software for the GravitationalWaves package.


### Background


> `GravitationalWaves`: a Python package designed to simulate, detect, and analyze continuous gravitational wave-forms. In addition to creating simulations of gravitational waves, the package also takes in observed data for comparison in detection and analysis.

`GravitationalWaves` is a Python package for simulating the gravitational waveforms of binary mergers of black holes and neutron stars, computing several properties of these mergers and waveforms, and evaluating their detectability. In addition, GravitationalWaves also takes in observed data from gravitational wave detectors to compare data and predict detection rates. 


**Definition.** Gravitational waves are invisible distortions in spacetime, caused by massive events such as collisions between two black holes or neutron stars.

The importance of studying gravitational waveforms stems from the idea of detecting and using gravity to estimate other dynamical astrophysical phenomena, giving enormous potential for discovering parts of the universe that are invisible to the eye, such as black holes and other unknowns. 




#### Package Data

```{r, fig.cap="Simulated Data Example"}
simulated.df <- read.csv("assets/data/out.csv")
kable(head(simulated.df, 8), col.names = c("Strain Amplitude", "Frequency"), escape = FALSE) %>%
  kable_styling(bootstrap_options = c("hover", "striped"), full_width = F, html_font = "Roboto", font_size = 11) %>%
  row_spec(0:8, hline_after = F, extra_css = "border-bottom: 1px solid #FEFEFE;") %>%
  column_spec(1, color = "#111111", extra_css = "font-weight: 400;") %>%
  column_spec(1:2, color = "#555", extra_css = "font-weight: 300;") %>%
  row_spec(0, color = "#111111", extra_css = "text-transform: uppercase; letter-spacing: 1.25px; font-weight: 400; font-size: 10px")
```




```{r}
table1 <- read.csv("assets/data/table1.csv")
table2 <- read.csv("assets/data/table2.csv")

colnames(table1) <- c("Source", "$I_\\mathrm{Gal}$", "$b_\\mathrm{Gal}$",
                      "Orbital Period", "$m_1$", "$m_2$", 
                      "t", "Refs", "Type")

colnames(table2) <- c("Source", "f (mHz)", "$\\beta$ (mas)",
                      "$\\sigma_\\beta$ (mas)", "d (pc)", 
                      "$\\sigma_d$ (pc)", "$\\mathcal{A}$",
                      "SNR", "type")

```


```{r}
kable(table1, escape = FALSE) %>%
  remove_column(columns = 9) %>%
  kableExtra::group_rows(start_row = 1, end_row = 11, group_label = "AM CVn type") %>%
  kableExtra::group_rows(start_row = 12, end_row = 15, group_label = "Detached white dwarfs") %>%
  kableExtra::group_rows(start_row = 16, end_row = 16, group_label = "Hot subdwarf binaries") %>%
  kable_styling(bootstrap_options = c("hover", "striped"), full_width = F, html_font = "Roboto", font_size = 10.5) %>%
  row_spec(0:18, hline_after = F, extra_css = "border-bottom: 1px solid #FEFEFE;") %>%
  column_spec(1, color = "#111111", extra_css = "font-weight: 400;") %>%
  column_spec(2:8, color = "#555", extra_css = "font-weight: 300; font-family: Roboto Condensed !important;") %>%
  row_spec(0, color = "#111111", extra_css = "text-transform: uppercase; letter-spacing: 1.25px; font-weight: 400; font-size: 10px; font-family: Roboto;")
  
```


```{r}
kable(table2, escape = FALSE) %>% 
  remove_column(columns = 9) %>%
  kableExtra::group_rows(start_row = 1, end_row = 11, group_label = "AM CVn type") %>%
  kableExtra::group_rows(start_row = 12, end_row = 15, group_label = "Detached white dwarfs") %>%
  kableExtra::group_rows(start_row = 16, end_row = 16, group_label = "Hot subdwarf binaries") %>%
  kable_styling(bootstrap_options = c("hover", "striped"), full_width = F, html_font = "Roboto", font_size = 10.5) %>%
  row_spec(0:18, hline_after = F, extra_css = "border-bottom: 1px solid #FEFEFE;") %>%
  column_spec(1, color = "#111111", extra_css = "font-weight: 400;") %>%
  column_spec(2:8, color = "#555", extra_css = "font-weight: 300; font-family: Roboto Condensed !important;") %>%
  row_spec(0, color = "#111111", extra_css = "text-transform: uppercase; letter-spacing: 1.25px; font-weight: 400; font-size: 10px; font-family: Roboto;")
```



```{r, fig.cap="Parameters of the analytic fit the Galactic confusion noise as described by equation (14). The amplitude A has been fixed to $9 \\times 10^{−45}$."}
gcn <- data.frame("6 mo" = c(0.133, 243, 482, 917, 0.00258),
                  "1 yr" = c(0.171, 292, 1020, 1680, 0.00215),
                  "2 yr" = c(0.165, 299, 611, 1340, 0.00173),
                  "4 yr" = c(0.138, -221, 521, 1680, 0.00113),
                  row.names = c("$\\alpha$", "$\\beta$", "$\\kappa$",
                                "$\\gamma$", "$f_\\kappa$"))

kable(gcn, escape = FALSE, col.names = c("6 mo", "1 yr", "2 yr", "4 yr")) %>%
  kable_styling(bootstrap_options = c("hover", "striped"), full_width = F, html_font = "Roboto", font_size = 10.5) %>%
  row_spec(0:5, hline_after = F, extra_css = "border-bottom: 1px solid #FEFEFE; ") %>%
  column_spec(1, color = "#111111", extra_css = "font-weight: 400;") %>%
  column_spec(2:5, color = "#555", extra_css = "font-weight: 300; font-family: Roboto Condensed !important;") %>%
  row_spec(0, color = "#111111", extra_css = "text-transform: uppercase; letter-spacing: 1.25px; font-weight: 400; font-size: 10px; font-family: Roboto;")
```





#### Software Requirements


**List of Dependencies:**

- python >= 3.7
- pip >= 21.0.0
- units
- importlib
- numba >= 0.50
- numpy >= 1.16
- astropy >= 4.0
- scipy >= 1.5.0
- matplotlib >= 3.3.2
- seaborn >= 0.11.1
- schwimmbad >= 0.3.2
- legwork >= 0.2.4
- pip:
   - GravitationalWaves >= 0.1 
   





--------------------------------------------

## Description of user / use cases

Description of user / use cases (a.k.a., functional spec)

Usage Examples: 


<div class = "methods1">
<div class = "methods2">

1. [Instantiate a Source Class](https://github.com/hluebbering/GravitationalWaves/blob/main/examples/01_InstantiateSourceClass.ipynb) 
2. [Calculate Signal-to-Noise Ratio (SNR)](https://github.com/hluebbering/GravitationalWaves/blob/main/examples/02_CalculateSNR.ipynb)
3. [Plot Source Parameters Distribution](https://github.com/hluebbering/GravitationalWaves/blob/main/examples/03_PlotSourceDistribution.ipynb)
4. [Plot Sensitivity Curve](https://github.com/hluebbering/GravitationalWaves/blob/main/examples/04_Visualizations.ipynb)
5. [Simulate Gravitational Waves](https://github.com/hluebbering/GravitationalWaves/blob/main/examples/05_SimulateGravitationalWaves.ipynb)

</div> 
</div>


\ 



### Demo 1. Single source SNR calculation




The most basic use case for GravitationalWaves is to calculate the signal-to-noise ratio of a single stellar-mass binary system. Using the package's source module, we first generate a source class and then calculate its SNR.


```python
import GravitationalWaves as gw
import astropy.units as u
source = gw.source.Source(m_1 = 11 * u.Msun,
                          m_2 = 11 * u.Msun,
                          ecc = 0.3,
                          f_orb = 1e-4 * u.Hz,
                          dist = 9 * u.kpc,
                          interpolate_g = False)
                          
source.get_snr()
```

For this example, GravitationalWaves checks whether the source is eccentric/circular and evolving/stationary, and chooses the fastest method to accurately calculate the SNR. 




--------------------------------------------


## Software Modules/ Components 

The component code, which implements the logic needed to perform a step in your ML workflow. Description of software modules / components (a.k.a., component spec). The above should definitely include modules and classes, but detailed function explanation optional depending on size of project.




### Detailed specification (ComponentSpec)



This section describes the ComponentSpec. 

A component specification, which defines the following:

The component’s metadata, its name and description.
The component’s interface, the component’s inputs and outputs.
The component’s implementation, the Docker container image to run, how to pass inputs to your component code, and how to get the component’s outputs.



<div class="roundedlist">

1. psd.py
2. source.py
3. strain.py
4. utils.py
5. visualization.py
6. wavesim.py

</div>






------------------------

#### Metadata:


Name: Human-readable name of the component.

URL: http://www.pobox.com/~tranter

Description: A program that ejects removable media using software control. The eject program allows the user to eject removable media (typically CD-ROMs, floppy disks or Iomega Jaz or Zip disks) using software control. Eject can also control some multi-disk CD changers and even some devices' auto-eject features. Install eject if you'd like to eject removable media using software control.

BuildRequires: gettext
BuildRequires: libtool

Metadata: Standard object’s metadata:

  Annotations: A string key-value map used to add information about the component. Currently, the annotations get translated to Kubernetes annotations when the component task is executed on Kubernetes. 
  



#### Interface

inputs and outputs: Specifies the list of inputs/outputs and their properties. Each input or output has the following properties:

name: Human-readable name of the input/output. Name must be unique inside the inputs or outputs section, but an output may have the same name as an input.

description: Human-readable description of the input/output.

default: Specifies the default value for an input. Only valid for inputs.

type: Specifies the type of input/output. The types are used as hints for pipeline authors and can be used by the pipeline system/UI to validate arguments and connections between components. Basic types are String, Integer, Float, and Bool. See the full list of types defined by the Kubeflow Pipelines SDK.

optional: Specifies if input is optional or not. This is of type Bool, and defaults to False. Only valid for inputs.


inputs:
- {name: Training data}
- {name: Rounds, type: Integer, default: '30', description: 'Number of training rounds'}

outputs:
- {name: Trained model, type: XGBoost model, description: 'Trained XGBoost model'}





Implementation

implementation: Specifies how to execute the component instance. There are two implementation types, container and graph. (The latter is not in scope for this document.) In future we may introduce more implementation types like daemon or K8sResource.

container: Describes the Docker container that implements the component. A portable subset of the Kubernetes Container v1 spec.

image: Name of the Docker image.

command: Entrypoint array. The Docker image’s ENTRYPOINT is used if this is not provided.Each item is either a string or a placeholder. The most common placeholders are {inputValue: Input name}, {inputPath: Input name} and {outputPath: Output name}.

args: Arguments to the entrypoint. The Docker image’s CMD is used if this is not provided. Each item is either a string or a placeholder. The most common placeholders are {inputValue: Input name}, {inputPath: Input name} and {outputPath: Output name}.

env: Map of environment variables to set in the container.

fileOutputs: Legacy property that is only needed in cases where the container always stores the output data in some hard-coded non-configurable local location. This property specifies a map between some outputs and local file paths where the program writes the output data files. Only needed for components that have hard-coded output paths. Such containers need to be fixed by modifying the program or adding a wrapper script that copies the output to a configurable location. Otherwise the component may be incompatible with future storage systems.


implementation:
  container:
    image: gcr.io/ml-pipeline/xgboost-classifier-train@sha256:b3a64d57
    command: [
      /ml/train.py,
      --train-set, {inputPath: Training data},
      --rounds,    {inputValue: Rounds},
      --out-model, {outputPath: Trained model},
    ]





```md
gravitational-waves
 ┣ docs
 ┃ ┗ presentation.Rmd
 ┣ examples
 ┃ ┣ 01_InstantiateSourceClass.ipynb
 ┃ ┣ 02_CalculateSNR.ipynb
 ┃ ┣ 03_PlotSourceDistribution.ipynb
 ┃ ┣ 04_Visualizations.ipynb
 ┃ ┣ 05_SimulateGravitationalWaves.ipynb
 ┃ ┗ README.md
 ┣ GravitationalWaves
 ┃ ┣ tests
 ┃ ┃ ┣ test_psd.py
 ┃ ┃ ┣ test_source.py
 ┃ ┃ ┣ test_strain.py
 ┃ ┃ ┣ test_utils.py
 ┃ ┃ ┣ test_visualization.py
 ┃ ┃ ┣ test_wavesim.py
 ┃ ┃ ┗ __init__.py
 ┃ ┣ psd.py
 ┃ ┣ R.npy
 ┃ ┣ source.py
 ┃ ┣ strain.py
 ┃ ┣ utils.py
 ┃ ┣ visualization.py
 ┃ ┣ wavesim.py
 ┃ ┗ __init__.py
 ┣ LICENSE
 ┣ README.md
 ┗ setup.py
```

 
 


--------------------------------------------


### Software Design Decisions

inclusion of software design decisions


Discussion of at least two design decisions made and why you made them	6


Design considerations:
* Giving optional parameters for more complex stuff by user. Extensibility!
* Forces users to be using Pandas DF.

scikit-learn workflow:
from sklearn.ensemble import RandomForestClassifier
from sklearn.datasets import load_iris
from sklearn.preprocessing import test_train_split

data = load_iris()
model = RandomForestClassifier(n_trees=10)
train_X, train_y, test_X, test_y = test_train_split(data.drop(["label"], axis=1), data["label"])
model.fit(data)

* Maintain information about the transformations that take place.







--------------------------------------------

## Comparison 

Comparison to the design of some existing software library	


--------------------------------------------

## Discussion of extensibility


extensibility of the software. 

Discussion of extensibility of your software (i.e., how difficult is it to extend?)	


--------------------------------------------



## References 
