---
title: "Gravitational-Waves"
subtitle: "Gravitational Wave Analysis in Python"
author: "Hannah Luebbering"
output:
  # html_document: 
  #   css: assets/main.css
  #   toc: yes
  #   toc_float: yes
  xaringan::moon_reader:
    css: assets/main2.css
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = ".") })
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

```



## Background

> `GravityPy` is a Python package designed to simulate, detect, and analyze continuous gravitational wave-forms. 

**Definition.** Gravitational waves are invisible distortions in spacetime, caused by massive events such as collisions between two black holes or neutron stars, that travel at the speed of light. 

These waveforms are important to study because they use gravity to take measure of dynamical astrophysical phenomena, giving enormous potential for discovering parts of the universe that are invisible to our eyes, such as black holes and other unknown objects.


`GravityPy` is a Python package to simulate the gravitational waveforms of binary mergers of black holes and neutron stars, and calculate several properties of these mergers and waveforms, specifically relating to their detectability by gravitational wave detectors.

In addition, GravityPy also takes in observed data from gravitational wave detectors, such as the Laser Interferometer Space Antenna (LISA), to compare data and predict detection rates.




---



## Data Description


> What data did you use? How was it obtained? What are its limitations?


This package uses both simulated data of gravitational waves and observed data from gravitational wave detectors, such as the Laser Interferometer Space Antenna (LISA).

A major factor in the successful detection and analysis of gravitational wave signals is the creation of simulations of such signals which observed data can be compared to.

We obtain the simulated data by implementing functions in the package that create simulations of gravitational waveform signals from a binary merger of two blacks holes or neutron stars, and outputting the data of such signals in terms of frequency and strain amplitude. The observed data is pre-loaded LISA verification binaries, which was obtained from the Kupfer study. 

The limitations of this data include that both simulated and observed calculations apply low-order post-Newtonian descriptions of gravitational wave emissions, which means that any higher order effects are not accounted for in the data. Hence, GravityPy may not be representative of the true SNR for sources that depend on these higher order effects or have masses over a few tens of solar masses.



---


## Use Cases

> How users will interact with your system in a way that addresses the problem area.


GravityPy is designed to provide users with quick estimates of the signal-to-noise ratio of stellar-mass sources of gravitational waves. Users can then use these calculations to study and predict the behavior of gravitational waves and plot functions for visualizing all of the results in the package. For example, the package's LISA simulator tools helps users determine which sources in a large population containing millions of binaries will be potentially detectable by LISA.





---


## Demo

> Demonstrate your software.



## Single source SNR calculation


The most basic use case of GravityPy is to calculate the signal-to-noise ratio for a single stellar-mass binary system. Using the package's source module, a high level interface for all package functionality, we first generate a source class and then calculate its SNR (for a 4-year LISA mission by default).

```python
import GravityPy as gp
import astropy.units as u

source = gp.source.Source(m_1 = 10 * u.Msun,
                          m_2 = 10 * u.Msun,
                          ecc = 0.2,
                          f_orb = 1e-4 * u.Hz,
                          dist = 8 * u.kpc,
                          interpolate_g = False)
                          
source.get_snr()
```

For this example, GravityPy checks whether the source is eccentric/circular and evolving/stationary and picks the fastest way to calculate the SNR accurately, returning the value `array([4.49])`. 


---

## Multiple source SNR calculate

In the next example, we use GravityPy to calculate the detectability of a collection of sources.

We begin by importing the source and visualization modules of GravityPy and some other common packages.

```python
import legwork.source as source
import legwork.visualisation as vis

import numpy as np
import astropy.units as u
import matplotlib.pyplot as plt
```


Next we create a random collection of possible LISA sources in order to assess their detectability.

```python
# create a random collection of sources
n_values = 1500
m_1 = np.random.uniform(0, 10, n_values) * u.Msun
m_2 = np.random.uniform(0, 10, n_values) * u.Msun
dist = np.random.normal(8, 1.5, n_values) * u.kpc
f_orb = 10**(-5 * np.random.power(3, n_values)) * u.Hz
ecc = 1 - np.random.power(5, n_values)
```

---

Using these random sources, we can instantiate a Source class to analyse the population.

```python
sources = source.Source(m_1 = m_1, m_2 = m_2, ecc = ecc, dist = dist, f_orb = f_orb)
```

---

Now, we can calculate the SNR (signal-to-noise ratio) for these sources. This function will split the sources based on whether they are stationary/evolving and circular/eccentric and use one of 4 SNR functions for each subpopulation.


```python
snr = sources.get_snr(verbose=True)
```

<div class="blockquote2">
Calculating SNR for 1500 sources
        0 sources have already merged
        1385 sources are stationary
                427 sources are stationary and circular
                958 sources are stationary and eccentric
        115 sources are evolving
                33 sources are evolving and circular
                82 sources are evolving and eccentric
</div>

These SNR values are now stored in sources.snr and we can mask those that don’t meet some detectable threshold.

```python
detectable_threshold = 7
detectable_sources = sources.snr > 7
print("{} of the {} sources are detectable".format(len(sources.snr[detectable_sources]), n_values))
```

585 of the 1500 sources are detectable


Hence, now we know the number of detectable sources. In addition, the Source class also has methods for calculating strains, visualizing populations and more. 






---


## Design 

> Describe the components (modules, classes, and functions) and how they interact to accomplish the use cases.



### Modules:

1. **utils.py**

The utils.py module contains several functions that compute and return the following:

- Chirp mass (m_c) 
- Relative power of gravitational radiation at nth harmonic (g(n, e) from Peters and Matthews (1963) Eq. 20)
- Enhancement factor (f(e) from Peters and Mathews (1963) Eq.17)
- Orbital frequency (f_orb)
                
                
2. **vis.py**

The vis.py module enables matplotlib based visualizations of the results, containing several functions that plot the following:

- 1D distribution of source
- 2D distribution of source
- LISA sensitivity curve
    
     
     
3. **source.py**

The source.py module provides a simple interface to the functions in all other modules. The module contains the generic gravitational wave class: **class Source()**. 

- This class is for analyzing a generic set of sources that may be stationary/evolving and circular/eccentric. 

```python
def __init__(self, m_1, m_2, ecc, dist, n_proc = 1, f_orb = None, 
             a = None, position = None, polarisation = None, 
             inclination = None, weights = None, gw_lum_tol = 0.05, 
             stat_tol = 1e-2, interpolate_g=True, interpolate_sc=True,
             sc_params={}):
             
             
```



                 
---


## Project Structure

> Show the structure of your github repository.


The structure of the GravityPy github repository is as follows:

- **README.md** : file gives an overview of the project
- **LICENSE** : open source MIT License
- **setup.py** : file initializes the project after it has been cloned
- **docs** : folder contains documentation (including the functional specification, design specification, and final project presentation)
- **GravityPy** : python package folder that is structured as one or more python modules (e.g., with init.py files) and test files
    - **__init__.py** 
    - **source.py** : module 
    - **utils.py** : module
    - **visualization.py** : module
    - **tests** : folder contains test files for the modules 
- **examples** : folder contains examples of using the packages
    - 01_simulate_gravitational_waves.py
    - 02_calculate_SNR.py
    - 03_horizon_distance.py





---


## Lessons learned 


Focus on software engineering lessons.



Package your code to share it with other developers. For example, to share a library for other developers to use in their application, or for development tools like ‘py.test’.

An advantage of this method of distribution is its well established ecosystem of tools such as PyPI and pip, which make it easy for other developers to download and install your package either for casual experiments, or as part of large, professional systems.

It is a well-established convention for Python code to be shared this way. If your code isn’t packaged on PyPI, then it will be harder for other developers to find it and to use it as part of their existing process. They will regard such projects with substantial suspicion of being either badly managed or abandoned.

The downside of distributing code like this is that it relies on the recipient understanding how to install the required version of Python, and being able and willing to use tools such as pip to install your code’s other dependencies. This is fine when distributing to other developers, but makes this method unsuitable for distributing applications to end-users.

The Python Packaging Guide provides an extensive guide on creating and maintaining Python packages.



LEGWORK (LISA Evolution and Gravitational Wave ORbit Kit) is a python package designed to calculate signal-to-noise ratios for GWs emitted from inspiraling binary systems that are potentially observable by LISA.

LEGWORK also contains a plotting module so you can show off those detectable GW sources of yours and treats any and all kinds of stellar-origin inspiralling binaries. Circular and stationary? No problem! Eccentric and chirping? We've got you covered!

Want to determine if your favorite source is detectable by LISA? Let LEGWORK do the legwork and keep the LISA literature free from spurious factors of 2!

---



## Future work


Overall, GravityPy is designed to help calculate binary sources of gravitational-waves, either simulated or like LISA. The goal of this package is to allow ways to study and better understand the detectability of such compact-object binaries. Future work includes adding more functions, equations, and modules to the package to implement and analyze gravitational-wave emission, gravitational wave strain, SNR, and visualization modules, and see these implementations effect on orbital evolution. This would require adding more modules and functions to calculate higher-level linear-algebra based equations and mathematical models.





